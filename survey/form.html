<script type="module">
	/* ---------- Configuration ---------- */
	const CSV_URL = 'questions.csv';
	const FORMSPREE_ENDPOINT = 'https://formspree.io/f/xrbyjror';
	const MODEL_COLS = [
		'google__gemini-2.5-flash-lite__content',
		'meta-llama__llama-4-maverick__content',
		'openai__gpt-4o-mini__content',
		'qwen__qwen3-vl-8b-instruct__content'
	];

	/* ---------- Util ---------- */
	function rng(seed) {
		let t = seed >>> 0;
		return () => {
			t |= 0;
			t = (t + 0x6d2b79f5) | 0;
			let r = Math.imul(t ^ (t >>> 15), 1 | t);
			r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
			return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
		};
	}
	function shuffle(a, rand = Math.random) {
		const x = a.slice();
		for (let i = x.length - 1; i > 0; i--) {
			const j = Math.floor(rand() * (i + 1));
			[x[i], x[j]] = [x[j], x[i]];
		}
		return x;
	}
	function seedFromCrypto() {
		const b = new Uint32Array(1);
		crypto.getRandomValues(b);
		return b[0];
	}
	function clamp(n, min, max) {
		return Math.max(min, Math.min(max, n));
	}

	/* ---------- Load Papa Parse ---------- */
	await new Promise((ok, err) => {
		const s = document.createElement('script');
		s.src = 'https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js';
		s.onload = ok;
		s.onerror = err;
		document.head.appendChild(s);
	});

	/* ---------- Load questions (CSV schema: one row per image with four model columns) ---------- */
	async function loadQuestions() {
		const res = await fetch(CSV_URL, { cache: 'no-store' });
		const text = await res.text();
		const { data } = Papa.parse(text, { header: true, skipEmptyLines: true });
		const qs = [];
		for (const row of data) {
			if (!row || !row.objectid) continue;
			const id = String(row.objectid).trim();
			const title = String(row.title || '').trim();
			const options = [];
			for (const col of MODEL_COLS) {
				let label = String(row[col] || '').trim();
				if (!label) {
					label =
						'Für diese Abbildung hat das Model fälschlicherweise kein Alternativtext generiert.';
				}
				options.push({ id: col, label });
			}
			if (options.length < 2) continue; // skip malformed rows
			qs.push({
				id,
				title: title,
				img: `images/${id}.jpg`,
				options
			});
			if (qs.length === 20) break; // enforce 20 images if file contains more
		}
		return qs;
	}

	/* ---------- State ---------- */
	const state = {
		seed: seedFromCrypto(),
		email: '',
		consent: false,
		questions: [],
		qOrder: [],
		idx: 0,
		// final/live order (mutates as the user reorders)
		answersById: {}, // { [objectid]: [model_col, ...] }
		timestampsById: {}, // { [objectid]: ISOString } last change
		// initial frozen order captured on first render
		initialOrderById: {}, // { [objectid]: [model_col, ...] }
		initialTimestampsById: {} // { [objectid]: ISOString }
	};

	/* ---------- UI refs (Grouped for maintainability) ---------- */
	const ui = {
		pageIntro: document.getElementById('page-intro'),
		pageQ: document.getElementById('page-q'),
		pageFinish: document.getElementById('page-finish'),
		startBtn: document.getElementById('start'),
		consent: document.getElementById('consent'),
		email: document.getElementById('email'),
		emailMsg: document.getElementById('email-msg'),
		progress: document.getElementById('progress'),
		imgEl: document.getElementById('q-image'),
		captionEl: document.getElementById('q-caption'),
		instrEl: document.getElementById('q-instr'),
		prevBtn: document.getElementById('prev'),
		nextBtn: document.getElementById('next'),
		rankList: document.getElementById('rank-list'),
		liveRegion: document.getElementById('aria-live'),
		submitBtn: document.getElementById('submit'),
		sendMsg: document.getElementById('send-msg'),
		summary: document.getElementById('summary')
	};

	function show(el) {
		[ui.pageIntro, ui.pageQ, ui.pageFinish].forEach((p) => p.classList.add('d-none'));
		el.classList.remove('d-none');
	}

	function currentQuestion() {
		const qid = state.qOrder[state.idx];
		return state.questions.find((q) => q.id === qid);
	}

	/* ---------- Render ---------- */
	function renderQuestion() {
		const q = currentQuestion();
		ui.progress.textContent = `Frage ${state.idx + 1} von ${state.qOrder.length}`;
		ui.imgEl.src = q.img;
		ui.imgEl.alt = q.title || 'Abbildung';
		ui.captionEl.innerHTML = `<strong>${q.title || 'Ohne Titel'}</strong>`;
		ui.instrEl.textContent =
			'Ordne die vier Beschreibungen per Drag & Drop. Beste nach oben. Schlechteste nach unten. Tastatur: ↑/↓ verschieben, 1–4 springt zur Position.';

		// Initial order: previously saved ranking or shuffled
		let orderIds = state.answersById[q.id];
		if (!orderIds) {
			const shuffled = shuffle(q.options, rng(state.seed + state.idx));
			orderIds = shuffled.map((o) => o.id);
			state.answersById[q.id] = orderIds.slice();
		}

		// Freeze and timestamp the initial randomized order once
		if (!state.initialOrderById[q.id]) {
			state.initialOrderById[q.id] = orderIds.slice();
			state.initialTimestampsById[q.id] = new Date().toISOString();
		}

		// Build list …
		ui.rankList.innerHTML = '';
		ui.rankList.setAttribute('aria-label', `Ranking für ${q.title}`);
		const size = orderIds.length;
		orderIds.forEach((optId, i) => {
			const opt = q.options.find((o) => o.id === optId);
			const li = document.createElement('li');
			li.className = 'rank-item';
			li.draggable = true;
			li.tabIndex = 0;
			li.dataset.id = opt.id;
			li.setAttribute('role', 'option');
			li.setAttribute('aria-roledescription', 'verschiebbare Option');
			li.setAttribute('aria-setsize', String(size));
			li.setAttribute('aria-posinset', String(i + 1));
			li.setAttribute('aria-grabbed', 'false');

			const badge = document.createElement('span');
			badge.className = 'rank-badge';
			badge.textContent = String(i + 1);

			const text = document.createElement('div');
			text.className = 'rank-text';
			text.textContent = opt.label;

			const handle = document.createElement('span');
			handle.className = 'rank-handle';
			handle.setAttribute('aria-hidden', 'true');
			handle.textContent = '⋮⋮';

			li.appendChild(badge);
			li.appendChild(text);
			li.appendChild(handle);
			ui.rankList.appendChild(li);
		});
		updateNavButtons();
	}

	function updatePosAria() {
		const items = [...ui.rankList.querySelectorAll('.rank-item')];
		items.forEach((el, i) => {
			el.setAttribute('aria-posinset', String(i + 1));
			const b = el.querySelector('.rank-badge');
			if (b) b.textContent = String(i + 1);
		});
	}

	function saveCurrentRanking() {
		const q = currentQuestion();
		const ids = [...ui.rankList.querySelectorAll('.rank-item')].map((el) => el.dataset.id);
		state.answersById[q.id] = ids;
		state.timestampsById[q.id] = new Date().toISOString();
	}

	function restoreFocusAfterReorder(targetId) {
		const el = ui.rankList.querySelector(`.rank-item[data-id="${CSS.escape(targetId)}"]`);
		if (el) el.focus();
	}

	function updateNavButtons() {
		ui.prevBtn.classList.toggle('disabled', state.idx === 0);
		ui.nextBtn.textContent = state.idx === state.qOrder.length - 1 ? 'Zur Auswertung' : 'Weiter';
	}

	function escapeHtml(s) {
		return s.replace(
			/[&<>"']/g,
			(m) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' })[m]
		);
	}

	/* ---------- Drag & Drop ---------- */
	let dragId = null;

	ui.rankList.addEventListener('dragstart', (e) => {
		const li = e.target.closest('.rank-item');
		if (!li) return;
		dragId = li.dataset.id;
		li.setAttribute('aria-grabbed', 'true');
		li.classList.add('dragging');
		e.dataTransfer.setData('text/plain', dragId);
		e.dataTransfer.effectAllowed = 'move';
		ui.liveRegion.textContent = `Greife Element, Position ${li.getAttribute('aria-posinset')}.`;
	});

	ui.rankList.addEventListener('dragend', (e) => {
		const li = e.target.closest('.rank-item');
		if (li) {
			li.setAttribute('aria-grabbed', 'false');
			li.classList.remove('dragging');
		}
		dragId = null;
		saveCurrentRanking();
		updatePosAria();
	});

	ui.rankList.addEventListener('dragover', (e) => {
		e.preventDefault();
		const after = getDragAfterElement(ui.rankList, e.clientY);
		const dragging = ui.rankList.querySelector('.dragging');
		if (!dragging) return;
		if (after == null) {
			ui.rankList.appendChild(dragging);
		} else {
			ui.rankList.insertBefore(dragging, after);
		}
	});

	function getDragAfterElement(container, y) {
		const els = [...container.querySelectorAll('.rank-item:not(.dragging)')];
		return (
			els
				.map((el) => {
					const box = el.getBoundingClientRect();
					const offset = y - box.top - box.height / 2;
					return { el, offset };
				})
				.filter((x) => x.offset < 0)
				.sort((a, b) => b.offset - a.offset)[0]?.el || null
		);
	}

	/* ---------- Keyboard reordering ---------- */
	ui.rankList.addEventListener('keydown', (e) => {
		const item = e.target.closest('.rank-item');
		if (!item) return;

		const items = [...ui.rankList.querySelectorAll('.rank-item')];
		const idx = items.indexOf(item);
		const last = items.length - 1;

		if (e.key === 'ArrowUp') {
			e.preventDefault();
			if (idx > 0) {
				ui.rankList.insertBefore(item, items[idx - 1]);
				updatePosAria();
				saveCurrentRanking();
				restoreFocusAfterReorder(item.dataset.id);
				ui.liveRegion.textContent = `Verschoben auf Position ${idx}.`;
			}
		} else if (e.key === 'ArrowDown') {
			e.preventDefault();
			if (idx < last) {
				ui.rankList.insertBefore(items[idx + 1], item);
				updatePosAria();
				saveCurrentRanking();
				restoreFocusAfterReorder(item.dataset.id);
				ui.liveRegion.textContent = `Verschoben auf Position ${idx + 2}.`;
			}
		} else if (/^[1-9]$/.test(e.key)) {
			const pos = clamp(parseInt(e.key, 10) - 1, 0, last);
			e.preventDefault();
			if (pos !== idx) {
				if (pos === last) {
					ui.rankList.appendChild(item);
				} else {
					const ref = [...ui.rankList.querySelectorAll('.rank-item')][pos];
					ui.rankList.insertBefore(item, ref);
				}
				updatePosAria();
				saveCurrentRanking();
				restoreFocusAfterReorder(item.dataset.id);
				ui.liveRegion.textContent = `Gesetzt auf Position ${pos + 1}.`;
			}
		}
	});

	/* ---------- Flow ---------- */
	ui.startBtn.addEventListener('click', async () => {
		state.email = ui.email.value.trim();
		state.consent = ui.consent.checked;

		if (!state.consent) {
			ui.emailMsg.textContent = 'Bitte Einwilligung erteilen.';
			return;
		}
		if (!state.email) {
			ui.emailMsg.textContent = 'E-Mail ist erforderlich.';
			return;
		}
		if (!/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(state.email)) {
			ui.emailMsg.textContent = 'Ungültige E-Mail.';
			return;
		}

		state.questions = await loadQuestions();
		if (!state.questions.length) {
			ui.emailMsg.textContent = 'Keine Fragen geladen. Prüfe questions.csv.';
			return;
		}
		state.qOrder = shuffle(
			state.questions.map((q) => q.id),
			rng(state.seed)
		);
		state.idx = 0;
		state.answersById = {};
		show(ui.pageQ);
		renderQuestion();
		ui.emailMsg.textContent = '';
	});

	ui.nextBtn.addEventListener('click', () => {
		saveCurrentRanking();
		if (state.idx < state.qOrder.length - 1) {
			state.idx++;
			renderQuestion();
		} else {
			const done = Object.keys(state.answersById).length;
			ui.summary.textContent = `Bereit zum Senden. ${done} vollständige Rankings erfasst.`;
			show(ui.pageFinish);
		}
	});

	ui.prevBtn.addEventListener('click', () => {
		if (state.idx > 0) {
			saveCurrentRanking();
			state.idx--;
			renderQuestion();
		}
	});

	ui.submitBtn.addEventListener('click', async () => {
		// Validate completion
		const expected = state.qOrder.length;
		const done = Object.keys(state.answersById).length;
		if (done !== expected) {
			alert(`Es fehlen Rankings. Erfasst: ${done} von ${expected}.`);
			return;
		}

		// Build compact payload
		const answers = state.qOrder.map((qid) => {
			const q = state.questions.find((x) => x.id === qid);

			// 1. Get FINAL order and texts
			const finalOrder = state.answersById[qid] || [];
			const final_order_ids = {};
			const final_order_texts = {};
			finalOrder.forEach((optId, i) => {
				const rankNum = i + 1;
				const label = q.options.find((o) => o.id === optId)?.label || '';
				final_order_ids[String(rankNum)] = optId;
				final_order_texts[String(rankNum)] = label.length > 1200 ? label.slice(0, 1200) : label;
			});

			// 2. Get INITIAL order
			const initialOrder = state.initialOrderById[qid] || [];
			const initial_order_ids = {};
			initialOrder.forEach((optId, i) => {
				initial_order_ids[String(i + 1)] = optId;
			});

			return {
				objectid: qid,
				img: q.img,

				// Add both timestamps for comparison
				timestamp_initial_utc: state.initialTimestampsById[qid] || null,
				timestamp_final_utc: state.timestampsById[qid] || new Date().toISOString(),

				// Add both initial and final rankings
				initial_order_ids,
				final_order_ids,
				final_order_texts
			};
		});

		const payload = {
			seed: String(state.seed),
			email: state.email,
			answers
		};

		ui.sendMsg.textContent = 'Senden…';
		try {
			const r = await fetch(FORMSPREE_ENDPOINT, {
				method: 'POST',
				headers: { Accept: 'application/json', 'Content-Type': 'application/json' },
				body: JSON.stringify(payload)
			});
			ui.sendMsg.textContent = r.ok ? 'Danke. Antworten gespeichert.' : 'Fehler beim Senden.';
			if (r.ok) ui.submitBtn.disabled = true;
		} catch (err) {
			ui.sendMsg.textContent = 'Netzwerkfehler: ' + err;
		}
	});
</script>

<div class="container my-4" id="app">
	<div class="card" id="page-intro">
		<div class="card-body">
			<h3 class="card-title mb-3">Studie: Vergleich von Alternativtexten</h3>
			<p class="text-muted">
				Auf jeder Seite sehen Sie ein Sammlungsbild und vier kurze Beschreibungen. Ordnen Sie die
				Beschreibungen von <strong>beste Beschreibung</strong> nach
				<strong>schlechteste Beschreibung</strong>
				per Drag &amp; Drop. Alle Texte wurden automatisch generiert und können Fehler enthalten.
			</p>

			<div class="mb-2">
				<strong>Bewertungsregeln nach WCAG-Intention:</strong>
				<ul class="small mb-2">
					<li>Kerninhalt des Bildes knapp und sachlich wiedergeben.</li>
					<li>Kein «Bild von…», keine redundanten Metadaten, keine Wertungen.</li>
					<li>Wesentliche visuelle Merkmale priorisieren; Kontext nur bei Verständnishilfe.</li>
					<li>
						Weiterführende Links:
						<a
							href="https://www.hilfsgemeinschaft.at/aktuelles/blog/detail/7-regeln-fuer-gute-alt-texte/"
							target="_blank"
							rel="noopener"
							>7 Regeln für gute Alt-Texte</a
						>
						(nur lesen, falls Unklarheiten bestehen)
					</li>
				</ul>
				<p class="small text-muted mb-1">
					<strong>Tastatur:</strong> ↑/↓ verschiebt fokussierten Eintrag; 1–4 setzt direkt auf
					Position; Tab für Fokus.
				</p>
				<p class="small text-muted">
					Fokus-Indikator sichtbar. Elemente sind per ARIA ausgezeichnet.
				</p>
			</div>

			<div class="mb-3">
				<label for="email" class="form-label">E-Mail<span class="text-danger">*</span></label>
				<input
					id="email"
					type="email"
					class="form-control"
					placeholder="name@example.org"
					required
				/>
			</div>

			<div class="form-check mb-3">
				<input class="form-check-input" type="checkbox" id="consent" />
				<label class="form-check-label" for="consent">
					Ich willige in die Verarbeitung meiner Daten für diese Studie ein.
				</label>
			</div>

			<button id="start" class="btn btn-primary">Start</button>
			<p id="email-msg" class="text-muted mt-2"></p>
		</div>
	</div>

	<div class="card d-none" id="page-q">
		<div class="card-body">
			<div id="progress" class="text-muted mb-3"></div>

			<div class="q-grid">
				<figure class="figure mb-0 text-center q-figure">
					<img id="q-image" class="q-image img-fluid" alt="" />
					<figcaption id="q-caption" class="small text-muted mt-2"></figcaption>
				</figure>

				<div class="q-right">
					<p id="q-instr" class="text-muted mb-2"></p>
					<ol
						id="rank-list"
						class="rank-list"
						role="listbox"
						aria-label="Ranking"
						aria-describedby="rank-help"
					></ol>
					<p id="rank-help" class="visually-hidden">
						Verschiebe Elemente per Drag und Drop oder nutze Pfeiltasten. Beste Beschreibung nach
						oben.
					</p>
					<div id="aria-live" class="visually-hidden" aria-live="polite"></div>

					<div class="d-flex gap-2 mt-3">
						<button
							id="prev"
							class="btn btn-outline-secondary"
							aria-label="Zurück zur vorherigen Frage"
						>
							Zurück
						</button>
						<button id="next" class="btn btn-primary" aria-label="Weiter zur nächsten Frage">
							Weiter
						</button>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="card d-none" id="page-finish">
		<div class="card-body">
			<h3 class="card-title mb-3">Abschluss</h3>
			<p class="text-muted" id="summary">Übermittlung…</p>
			<button id="submit" class="btn btn-primary">Antworten senden</button>
			<div id="send-msg" class="text-muted mt-2"></div>
		</div>
	</div>
</div>

<style>
	/* Q layout */
	.q-grid {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 1rem;
		align-items: start;
	}

	@media (max-width: 800px) {
		.q-grid {
			grid-template-columns: 1fr;
		}
	}

	.q-image {
		max-height: 60vh;
		width: auto;
		object-fit: contain;
	}

	.q-figure {
		margin: 0;
	}

	/* Ranking list */
	.rank-list {
		list-style: none;
		padding: 0;
		margin: 0;
		border: 1px solid #e5e7eb;
		border-radius: 0.5rem;
		background: #fff;
	}

	.rank-item {
		display: grid;
		grid-template-columns: auto 1fr auto;
		align-items: start;
		gap: 0.75rem;
		padding: 0.75rem;
		border-bottom: 1px solid #f1f5f9;
		background: #fff;
		outline: none;
	}

	.rank-item:last-child {
		border-bottom: 0;
	}

	/* Use Bootstrap's focus ring variable if available, otherwise fallback */
	.rank-item:focus {
		box-shadow: 0 0 0 3px var(--bs-primary-border-subtle, rgba(59, 130, 246, 0.45));
		border-radius: 0.375rem;
	}

	.rank-item.dragging {
		opacity: 0.75;
		background: #f8fafc;
	}

	.rank-badge {
		font-weight: 600;
		background: #eef2ff;
		color: #3730a3;
		border: 1px solid #c7d2fe;
		border-radius: 0.375rem;
		padding: 0.1rem 0.4rem;
		min-width: 1.6rem;
		text-align: center;
	}

	.rank-text {
		white-space: pre-wrap;
		word-break: break-word;
	}

	.rank-handle {
		cursor: grab;
		user-select: none;
		color: #9ca3af;
		align-self: center;
	}
</style>
